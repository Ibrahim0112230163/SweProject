-- Dungeon Crawler Game Schema
-- This creates the gamification layer for course learning

-- 1. Game Stats Table - Track player progress across all dungeon runs
CREATE TABLE public.game_stats (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL UNIQUE,
    
    -- Player Stats
    total_experience_points INTEGER DEFAULT 0,
    level INTEGER DEFAULT 1,
    total_rooms_cleared INTEGER DEFAULT 0,
    total_dungeons_completed INTEGER DEFAULT 0,
    
    -- Resources
    health_potions INTEGER DEFAULT 3, -- Hint system
    max_hp INTEGER DEFAULT 100,
    
    -- Achievements/Badges
    achievements JSONB DEFAULT '[]'::jsonb,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 2. Dungeon Runs Table - Track individual game sessions
CREATE TABLE public.dungeon_runs (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    course_id UUID REFERENCES public.course_analysis(id) ON DELETE CASCADE,
    
    -- Run Details
    difficulty TEXT CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')) DEFAULT 'beginner',
    total_rooms INTEGER DEFAULT 5, -- How many questions in this run
    rooms_cleared INTEGER DEFAULT 0,
    
    -- Score Tracking
    score INTEGER DEFAULT 0,
    max_score INTEGER, -- Based on total rooms
    
    -- Failed Skills - What the student struggled with
    failed_skills JSONB DEFAULT '[]'::jsonb, -- [{"skill": "Binary Search", "attempts": 2}]
    mastered_skills JSONB DEFAULT '[]'::jsonb, -- Skills they got right
    
    -- Session State
    status TEXT CHECK (status IN ('in_progress', 'completed', 'abandoned')) DEFAULT 'in_progress',
    current_hp INTEGER DEFAULT 100,
    hints_used INTEGER DEFAULT 0,
    
    -- Timestamps
    started_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    completed_at TIMESTAMP WITH TIME ZONE,
    
    -- Study Report Generation
    study_report JSONB -- Generated when run fails or completes
);

-- 3. Room Attempts Table - Track individual question attempts within a run
CREATE TABLE public.room_attempts (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    dungeon_run_id UUID REFERENCES public.dungeon_runs(id) ON DELETE CASCADE NOT NULL,
    
    -- Room Details
    room_number INTEGER NOT NULL, -- Which room in the dungeon (1-5, etc.)
    skill_tested TEXT NOT NULL, -- The skill this question is testing
    difficulty TEXT CHECK (difficulty IN ('easy', 'medium', 'hard')) NOT NULL,
    
    -- Question Data (generated by AI)
    question_text TEXT NOT NULL,
    correct_answer TEXT NOT NULL,
    wrong_answers JSONB NOT NULL, -- Array of 3 wrong answers
    explanation TEXT, -- Why this is the correct answer
    
    -- Student's Response
    student_answer TEXT,
    is_correct BOOLEAN,
    attempts_count INTEGER DEFAULT 1,
    hint_used BOOLEAN DEFAULT false,
    hint_content TEXT, -- From syllabus
    
    -- Timing
    time_spent_seconds INTEGER, -- How long they took
    answered_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Enable Row Level Security
ALTER TABLE public.game_stats ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.dungeon_runs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.room_attempts ENABLE ROW LEVEL SECURITY;

-- Policies for game_stats
CREATE POLICY "Users can view their own game stats" 
ON public.game_stats FOR SELECT 
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own game stats" 
ON public.game_stats FOR INSERT 
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own game stats" 
ON public.game_stats FOR UPDATE 
USING (auth.uid() = user_id);

-- Policies for dungeon_runs
CREATE POLICY "Users can view their own dungeon runs" 
ON public.dungeon_runs FOR SELECT 
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own dungeon runs" 
ON public.dungeon_runs FOR INSERT 
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own dungeon runs" 
ON public.dungeon_runs FOR UPDATE 
USING (auth.uid() = user_id);

-- Policies for room_attempts
CREATE POLICY "Users can view their own room attempts" 
ON public.room_attempts FOR SELECT 
USING (
    EXISTS (
        SELECT 1 FROM public.dungeon_runs 
        WHERE id = room_attempts.dungeon_run_id 
        AND user_id = auth.uid()
    )
);

CREATE POLICY "Users can insert their own room attempts" 
ON public.room_attempts FOR INSERT 
WITH CHECK (
    EXISTS (
        SELECT 1 FROM public.dungeon_runs 
        WHERE id = room_attempts.dungeon_run_id 
        AND user_id = auth.uid()
    )
);

CREATE POLICY "Users can update their own room attempts" 
ON public.room_attempts FOR UPDATE 
USING (
    EXISTS (
        SELECT 1 FROM public.dungeon_runs 
        WHERE id = room_attempts.dungeon_run_id 
        AND user_id = auth.uid()
    )
);

-- Create indexes for performance
CREATE INDEX idx_game_stats_user_id ON public.game_stats(user_id);
CREATE INDEX idx_dungeon_runs_user_id ON public.dungeon_runs(user_id);
CREATE INDEX idx_dungeon_runs_course_id ON public.dungeon_runs(course_id);
CREATE INDEX idx_dungeon_runs_status ON public.dungeon_runs(status);
CREATE INDEX idx_room_attempts_dungeon_run_id ON public.room_attempts(dungeon_run_id);

-- Function to initialize game stats for new users
CREATE OR REPLACE FUNCTION initialize_game_stats()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.game_stats (user_id)
    VALUES (NEW.id)
    ON CONFLICT (user_id) DO NOTHING;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to auto-create game stats when a user signs up
CREATE TRIGGER on_auth_user_created_game_stats
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION initialize_game_stats();

-- Function to update game stats after completing a dungeon
CREATE OR REPLACE FUNCTION update_game_stats_after_run()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status = 'completed' AND OLD.status = 'in_progress' THEN
        UPDATE public.game_stats
        SET 
            total_experience_points = total_experience_points + NEW.score,
            total_rooms_cleared = total_rooms_cleared + NEW.rooms_cleared,
            total_dungeons_completed = total_dungeons_completed + 1,
            level = FLOOR((total_experience_points + NEW.score) / 100) + 1,
            updated_at = now()
        WHERE user_id = NEW.user_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to update stats when dungeon is completed
CREATE TRIGGER on_dungeon_completed
    AFTER UPDATE ON public.dungeon_runs
    FOR EACH ROW EXECUTE FUNCTION update_game_stats_after_run();

COMMENT ON TABLE public.game_stats IS 'Tracks overall player progress and resources across all dungeon runs';
COMMENT ON TABLE public.dungeon_runs IS 'Individual dungeon game sessions with scores and failed skills tracking';
COMMENT ON TABLE public.room_attempts IS 'Individual question attempts within a dungeon run for detailed analytics';
